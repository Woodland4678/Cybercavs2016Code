// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import org.usfirst.frc4678.Cybercavs2016Code.commands.*;
import org.usfirst.frc4678.Cybercavs2016Code.subsystems.*;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 * hi
 */
public class Robot extends IterativeRobot {

	
	////////////////////////////////////////
	//////////Parameters for Elbow//////////
	////////////////////////////////////////

	public static int pickupElbowPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("pickupElbowPosition")) {
			prefs.putInt("pickupElbowPosition", 121332);
		}
		return prefs.getInt("pickupElbowPosition", 121332);
	}
	public static int restElbowPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("restElbowPosition")) {
			prefs.putInt("restElbowPosition", 66567);
		}
		return prefs.getInt("restElbowPosition", 66567);
	}
	public static int spitOutElbowPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("spitOutElbowPosition")) {
			prefs.putInt("spitOutElbowPosition", 28328);
		}
		return prefs.getInt("spitOutElbowPosition", 28328);
	}
	
	////////////////////////////////////////
	//////////Parameters for Wrist//////////
	////////////////////////////////////////
	
	public static int pickupWristPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("pickupWristPosition")) {
			prefs.putInt("pickupWristPosition", -5957);
		}
		return prefs.getInt("pickupWristPosition", -5957);
	}
	public static double restWristPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("restWristPosition")) {
			prefs.putDouble("restWristPosition", 50000);
		}
		return prefs.getDouble("restWristPosition", 50000);
	}
	public static int spitOutWristPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("spitOutWristPosition")) {
			prefs.putInt("spitOutWristPosition", -284041);
		}
		return prefs.getInt("spitOutWristPosition", -284041);
	}
	
	///////////////////////////////////////////
	//////////Parameters for Catapult//////////
	//////////////////////////////////////////
	
	public static double latchReadyPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("latchReadyPostion")) {
			prefs.putDouble("latchReadyPostion", 0);
		}
		return prefs.getDouble("pickupWheelsPower", 0);
	}
	public static double latchShootPosition() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("latchShootPosition")) {
			prefs.putDouble("latchShootPosition", 90);
		}
		return prefs.getDouble("pickupWheelsPower", 90);
	}
	public static double winchPower() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("winchPower")) {
			prefs.putDouble("winchPower", 0.8);
		}
		return prefs.getDouble("winchPower", 0.8);
	}
	public static double winchWoundDistance() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("winchWoundDistance")) {
			prefs.putDouble("winchWoundDistance", 9);
		}
		return prefs.getDouble("winchWoundDistance", 9);
	}
	public static double winchUnwoundDistance() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("winchUnwoundDistance")) {
			prefs.putDouble("winchUnwoundDistance", 0);
		}
		return prefs.getDouble("winchUnwoundDistance", 0);
	}
	
	///////////////////////////////////
	//////////Misc Parameters//////////
	///////////////////////////////////
	
	public static double pickupWheelsPower() {
		Preferences prefs = Preferences.getInstance();
		if (!prefs.containsKey("pickupWheelsPower")) {
			prefs.putDouble("pickupWheelsPower", 3);
		}
		return prefs.getDouble("pickupWheelsPower", 3);
	}
	

	Command autonomousCommand;

	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static RobotDrive robotDrive;
    public static PickupArm pickupArm;
    public static Catapult catapult;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	public void robotInit() {
		RobotMap.init();
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        robotDrive = new RobotDrive();
        pickupArm = new PickupArm();
        catapult = new Catapult();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to be
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.
		oi = new OI();

		// instantiate the command used for the autonomous period
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        autonomousCommand = new AutonomousCommand();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	}

	/**
	 * This function is called when the disabled button is hit. You can use it
	 * to reset subsystems before shutting down.
	 */
	public void disabledInit() {

	}

	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}

	public void autonomousInit() {
		// schedule the autonomous command (example)
		if (autonomousCommand != null)
			autonomousCommand.start();
	}

	/**
	 * This function is called periodically during autonomous
	 */
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}

	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null)
			autonomousCommand.cancel();
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
	}

	/**
	 * This function is called periodically during test mode
	 */
	public void testPeriodic() {
		LiveWindow.run();
	}
}
