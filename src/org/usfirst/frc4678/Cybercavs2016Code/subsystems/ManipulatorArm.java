// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4678.Cybercavs2016Code.subsystems;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;
import org.usfirst.frc4678.Cybercavs2016Code.RobotMap;
import org.usfirst.frc4678.Cybercavs2016Code.commands.*;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.StatusFrameRate;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class ManipulatorArm extends Subsystem {
	
	int SPEED_FACTOR = 25;
	
	enum joints {TIME, WRIST, ELBOW, LEFT, RIGHT}
	
	static public double wristPos = 0;
	static public double elbowPos = 0;
	static public double leftPos = 0;
	static public double rightPos = 0;
	static public double wristSpeed = 0;
	static public double elbowSpeed = 0;
	static public double leftSpeed = 0;
	static public double rightSpeed = 0;
	
	String manipulatorMode;
	int wristStartPosition = 0;
	int elbowStartPosition = 0;
	int count = 0;
	int sallyState = 0;
	int drawBridgeState = 0;
	int portcullisState = 0;
	int exitSallyState = 0;
	double currentWristPosition = 0;
	double previousWristPosition = 0;
	double wristPosition = 0;
	double elbowPosition = 0;
	double leftEncoder = 0;
	double rightEncoder = 0;
	double kWrist = 0;
	double kElbow = 0;
	double newElbowPosition = 0;
	double timeCount = 0;
	double totalTime = 0;
	double speed = 0;
	double encoderPosition = 0;
	double newWristPosition = 0;
	double fpgaDiff = 0;
	double lastFPGA = 0;
	public static int comboindex = 0;
//	public static double time = 0;
	public static double speed_mult = 0;
	boolean restWrist = false;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon manipulatorElbow = RobotMap.manipulatorArmmanipulatorElbow;
    private final CANTalon manipulatorWrist = RobotMap.manipulatorArmmanipulatorWrist;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    int elbowShootPosition = Robot.manipulatorElbowRestPosition() + 61766;
    int elbowPortcullisPosition = Robot.manipulatorElbowRestPosition() + 59846;
    int wristShootPosition = Robot.manipulatorWristRestPosition() - 9450;
    int wristPortcullisPosition = Robot.manipulatorWristRestPosition() - 8887;
    int wristRestPosition = Robot.manipulatorWristRestPosition();
    int wristStraightUpPosition = Robot.manipulatorWristRestPosition() - 35799;
    int wristSallyReady = Robot.manipulatorWristRestPosition() - 15086;
    int drawBridgeWristReady = Robot.manipulatorWristRestPosition() - 29834;
    int wristSecondPosition = Robot.manipulatorWristRestPosition() - 10068;
    int wristThirdPosition = Robot.manipulatorWristRestPosition() - 13098;
    int wristFourthPosition = Robot.manipulatorWristRestPosition() - 11753;
    int wristFifthPosition = Robot.manipulatorWristRestPosition() -17393
;

    int wristPortcullisReady = Robot.manipulatorWristRestPosition() -9658;
    int wristPortcullisSecond = Robot.manipulatorWristRestPosition() -12101;
    int wristPortcullisThird = Robot.manipulatorWristRestPosition() -20880;
    int wristPortcullisFourth = Robot.manipulatorWristRestPosition() -6762;
    int encoderPortcullisFirst = 260;
    int encoderPortcullisSecond = -365;
    int encoderPortcullisThird = -1265;

    int elbowAfterShootPosition = Robot.manipulatorElbowRestPosition() + 23337;
    int elbowStraightUpPosition = Robot.manipulatorElbowRestPosition() + 47493;
    int elbowSallyReady = Robot.manipulatorElbowRestPosition() + 42196;
    int drawBridgeElbowReady = Robot.manipulatorElbowRestPosition() + 39548;
    int elbowSecondPosition = Robot.manipulatorElbowRestPosition() + 20000; // was 15880
    int elbowThirdPosition = Robot.manipulatorElbowRestPosition() + 59688;
    int elbowFourthPosition = Robot.manipulatorElbowRestPosition() + 72387;
    int elbowFifthPosition = Robot.manipulatorElbowRestPosition() + 74346;
    int elbowSixthPosition = Robot.manipulatorElbowRestPosition() + 50000;
    
    int elbowPortcullisReady = Robot.manipulatorElbowRestPosition() + 70553;
    int elbowPortcullisSecond = Robot.manipulatorElbowRestPosition() + 66697;
    int elbowPortcullisThird = Robot.manipulatorElbowRestPosition() + 48123;
    int elbowPortcullisFourth = Robot.manipulatorElbowRestPosition() + 5786;
    
    int encoderSecondPosition = 338;
    int encoderThirdPosition = 750;
    int encoderFourthPosition = 750;
    int encoderFifthPosition = 273;
    
    int encoderSallyMax = 900;

    
    static double[][] portcullis = new double[][]{
    		{5.0,2689,2191,110,106},
    		{2.0,-9483.0, 68573.0, 110.0, 106.0},
    		{2.0,-9560.0, 62045.0, 110.0, 106.0},
    		{2.0,-9562.0, 55137.0, 110.0, 106.0},
    		{2.0,-11714.0, 50455.0, 110.0, 107.0},
    		{2.0,-15158.0, 49245.0, 110.0, 107.0},
    		{2.0,-10661.0, 40377.0, -103.0, -105.0},
    		{2.0,-8285.0, 25347.0, -278.0, -273.0},
    		{2.0,-6213.0, 8355.0, -454.0, -452.0},
    		{2.0,-3067.0, 2473.0, -528.0, -525.0},
    		{1.0,-3067.0, 2473.0, -528.0, -525.0},
    		};
    
    		
   static double[][] cheval = new double[][]{
			{1.5,-4852.0, 62487.0, -24.0, -23.0},
			{1.5,-1910.0, 48322.0, -24.0, -23.0},
			{1.5,-5416.0, 32160.0, -24.0, -23.0},
			{1.5,-5368.0, 45194.0, -106.0, -104.0},
			{1.5,-5143.0, 59423.0, -104.0, -102.0},
			{1.5,-5149.0, 67295.0, -104.0, -101.0},
			{1.5,-5171.0, 68752.0, -284.0, -274.0},
			{1.5,-2699.0, 37567.0, -280.0, -270.0},
			{1.5,2419.0, 2452.0, -544.0, -524.0},
			{1.5,2419.0, 2453.0, -785.0, -782.0},
			{1.5,2419.0, 2454.0, -921.0, -925.0},
			{0.75,2419.0, 2454.0, -921.0, -925.0},		
  	};
  	
  	static double[][] sally = new double[][]{
  			{2.5,-5572.0, 63552.0, -11.0, -11.0},
  			{2.5,-3887.0, 51708.0, -11.0, -11.0},
  			{2.5,-9412.0, 32606.0, -11.0, -11.0},
  			{2.5,-16908.0, 42705.0, -11.0, -11.0},
  			{2.5,-13727.0, 40044.0, -10.0, -10.0},
  			{2.5,-12768.0, 38069.0, 273.0, 269.0},
  			{2.5,-13107.0, 34085.0, 545.0, 556.0},
  			{2.5,-12607.0, 32702.0, 604.0, 692.0},
  			{2.5,-10412.0, 32451.0, 435.0, 792.0},
  			{2.5,-10412.0, 32451.0, 524.0, 533.0},
  			{2.5,-10412.0, 32451.0, -159.0, -137.0},
  			{1.25,-10412.0, 32451.0, -159.0, -137.0},
  	};
  	
  	static double[][] drawbridge = new double[][]{
  			{1.75,-5240.0, 64136.0, -20.0, -21.0},
  			{1.75,-2133.0, 39439.0, -19.0, -19.0},
  			{1.75,-5425.0, 22567.0, -20.0, -19.0},
  			{1.75,-18011.0, 33501.0, -20.0, -20.0},
  			{1.75,-27922.0, 47721.0, -20.0, -19.0},
  			{1.75,-24754.0, 47413.0, -20.0, -19.0},
  			{1.75,-23377.0, 47665.0, 257.0, 250.0},
  			{1.75,-17893.0, 46463.0, 567.0, 549.0},
  			{1.75,-9020.0, 52448.0, 643.0, 626.0},
  			{1.75,-10279.0, 76674.0, 641.0, 624.0},
  			{1.75,-6888.0, 76388.0, 466.0, 453.0},
  			{1.75,-6896.0, 77334.0, 299.0, 290.0},
  			{1.75,-5850.0, 41067.0, 125.0, 121.0},
  			{1.75,2626.0, 2418.0, -74.0, -78.0},
  			{0.625,2626.0, 2418.0, -74.0, -78.0},
  	};

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new SetManipulatorArm());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
   
	//////////////////////////////////////
	//////////Setter Functions//////////
	/////////////////////////////////////
    
    public void setManipulatorWrist(double position) {
    	manipulatorWrist.configPeakOutputVoltage(+12f, -12f); //max and min power
    	manipulatorWrist.setPID(0.27, 0, 0); //PID values
    	manipulatorWrist.setAllowableClosedLoopErr(20);
    	manipulatorWrist.set(position); // allowable error in the PID position movement
    }
    public void setManipulatorElbow(double position) {
    	manipulatorElbow.configPeakOutputVoltage(+12f, -12f); //max and min power
    	manipulatorElbow.setPID(0.27, 0, 0); //PID values
    	manipulatorElbow.setAllowableClosedLoopErr(20);
    	manipulatorElbow.set(position); // allowable error in the PID position movement
    }
    public void resetSallyState() {
    	sallyState = 0;
    }
    public void resetDrawBridgeState() {
    	drawBridgeState = 0;
    }
    public void resetPortcullisState() {
    	portcullisState = 0;
    }

    public void setManipulatorElbowMode(int mode) {
    	manipulatorElbow.setStatusFrameRateMs(StatusFrameRate.QuadEncoder, 10);
	
	// StatusFrameRateGeneral = 0, StatusFrameRateFeedback = 1, StatusFrameRateQuadEncoder = 2, StatusFrameRateAnalogTempVbat = 3, 
	//  StatusFrameRatePulseWidthMeas = 4 
		if (mode == 0) {
			manipulatorElbow.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			manipulatorElbow.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			manipulatorElbow.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			manipulatorElbow.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			manipulatorElbow.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			manipulatorElbow.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			manipulatorElbow.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			manipulatorElbow.changeControlMode(TalonControlMode.Voltage);
		}
	}
	public void setManipulatorWristMode(int mode) {
    	manipulatorWrist.setStatusFrameRateMs(StatusFrameRate.QuadEncoder, 10);
		if (mode == 0) {
			manipulatorWrist.changeControlMode(TalonControlMode.Current);
		}
		if (mode == 1) {
			manipulatorWrist.changeControlMode(TalonControlMode.Disabled);
		}
		if (mode == 2) {
			manipulatorWrist.changeControlMode(TalonControlMode.Follower);
		}
		if (mode == 3) {
			manipulatorWrist.changeControlMode(TalonControlMode.MotionProfile);
		}
		if (mode == 4) {
			manipulatorWrist.changeControlMode(TalonControlMode.PercentVbus);
		}
		if (mode == 5) {
			manipulatorWrist.changeControlMode(TalonControlMode.Position);
		}
		if (mode == 6) {
			manipulatorWrist.changeControlMode(TalonControlMode.Speed);
		}
		if (mode == 7) {
			manipulatorWrist.changeControlMode(TalonControlMode.Voltage);
		}
	}
	public void setManipulatorMode(String mode) {
		manipulatorMode = mode;
	}
	
	//////////////////////////////////////
	//////////Accessor Functions//////////
	/////////////////////////////////////
	
	public int getManipulatorWristPosition() {return manipulatorWrist.getEncPosition();}
	
	public int getManipulatorElbowPosition() {return manipulatorElbow.getEncPosition();}
	
	public int getManipulatorWristAngular() {return manipulatorWrist.getPulseWidthPosition();}
	
	public int getManipulatorElbowAngular() {return manipulatorElbow.getPulseWidthPosition();}
	
	public String getManipulatorMode() {return manipulatorMode;}
	
	public double getWristSpeed() {return manipulatorWrist.getSpeed();}
	
	public double getElbowSpeed() {return manipulatorElbow.getSpeed();}
	
	public double getElbowError() {return manipulatorElbow.getError();}
	
	//////////////////////////////////////
	//////////Movement Functions//////////
	/////////////////////////////////////
	
	
	public void restMode() {
		if (Math.abs(manipulatorElbow.getError()) < 2500 && count > 10) {
			setManipulatorWrist(Robot.manipulatorWristRestPosition());
		}
		else {
			setManipulatorWrist(Robot.manipulatorWristRestPosition() - 5000);
		}
	
			count++;
		setManipulatorElbow(Robot.manipulatorElbowRestPosition());
	}
	public void readyToShoot() {
		setManipulatorWrist(wristShootPosition);
		setManipulatorElbow(elbowShootPosition);
	}
	public void straightUp() {
		setManipulatorWrist(wristStraightUpPosition);
		setManipulatorElbow(elbowStraightUpPosition);
	}
	
	public void CalibrateManipulator() {
		wristStartPosition = (manipulatorWrist.getPulseWidthPosition() % 4096);
		elbowStartPosition = (manipulatorElbow.getPulseWidthPosition() % 4096);
		if (wristStartPosition < 0) {
			wristStartPosition = wristStartPosition + 4096;
		}
		if (elbowStartPosition < 0) {
			elbowStartPosition = elbowStartPosition + 4096;
		}
		manipulatorWrist.setPulseWidthPosition(wristStartPosition);
		manipulatorElbow.setPulseWidthPosition(elbowStartPosition);
		manipulatorWrist.setEncPosition(wristStartPosition);
		manipulatorElbow.setEncPosition(elbowStartPosition);
	}
	public void resetCount() {
		count = 0;
	}
	public void portcullis1() {
		switch(portcullisState) {
		
		case 0:
			setManipulatorElbow(elbowPortcullisPosition);
			setManipulatorWrist(wristPortcullisPosition);
			if(Math.abs(manipulatorElbow.getError()) < 100 && count > 10) {
				portcullisState++;
				manipulatorWrist.changeControlMode(TalonControlMode.Voltage);
				manipulatorElbow.changeControlMode(TalonControlMode.Voltage);
				manipulatorWrist.set(0);
				manipulatorElbow.set(0);
				count = 0;
			}
			count++;
		break;
		case 1:
			if(count > 10) {
				if (Math.abs(wristPortcullisPosition - currentWristPosition) > 300) {
					Robot.robotDrive.resetEncoders();
					count = 0;
					portcullisState++;
				}
				previousWristPosition = currentWristPosition;
			}
			count++;
			currentWristPosition = manipulatorWrist.getPosition();
		break;
		case 2:
			wristPosition = manipulatorWrist.getPosition();
			elbowPosition = manipulatorElbow.getPosition();
			leftEncoder = Robot.robotDrive.getLeftEncoder();
			rightEncoder = Robot.robotDrive.getRightEncoder();
			System.out.println(wristPosition + ", " + elbowPosition + ", " + leftEncoder + ", " + rightEncoder);
		}
	}

	public static double interp(double time, double start, double end, double from, double to) { // Do the interpolation calculation
		return((to - from)*((time - start) / (end - start)) + from);
    }
	
	public static boolean lookup(double time){ // do a lookup of the position information and also calculate speed data
		// First, find the correct time offset into the data
		int x, arysize;
		double time_accumulator = 0, find_time = 0;
		double start_time = 0, end_time = 0;
		boolean found,done;
		double start_pos1 = 0, end_pos1 = 0, pos1 = 0, speed1 = 0;
		double start_pos2 = 0, end_pos2 = 0, pos2 = 0, speed2 = 0;
		double start_pos3 = 0, end_pos3 = 0, pos3 = 0, speed3 = 0;
		double start_pos4 = 0, end_pos4 = 0, pos4 = 0, speed4 = 0;
		
		double speed_multiplier = speed_mult;
		
		double timeoffset = time * speed_multiplier;
		
		int dataset = comboindex;
		// Now, try to look this up in the correct dataset
		if (dataset == 0)
		    arysize = portcullis.length;
		else if (dataset == 1)
		    arysize = cheval.length; 
		else if (dataset == 2)
		    arysize = sally.length; 
		else if (dataset == 3)
		    arysize = drawbridge.length; 
		else
		    return false; // dataset is out of range.  Return false.  Lookup fails
		
		found = false; // Indicate we have not yet found the dataset elements in the desired time range
		done = false;
		x = 0;
		time_accumulator = 0.0;
		find_time = time * speed_multiplier;
		while((!found)&&(!done)) {
		    switch(dataset) {
		        case 0: // portcullis
		            start_time = time_accumulator;
		            end_time = time_accumulator + portcullis[x][joints.TIME.ordinal()];
		            if ((find_time >= start_time)&&(find_time < end_time))
		                { // If we are in the right time space, set up data for each axis
		                start_pos1 = portcullis[x][joints.WRIST.ordinal()];
		                end_pos1 = portcullis[x+1][joints.WRIST.ordinal()];
		                start_pos2 = portcullis[x][joints.ELBOW.ordinal()];
		                end_pos2 = portcullis[x+1][joints.ELBOW.ordinal()];
		                start_pos3 = portcullis[x][joints.LEFT.ordinal()];
		                end_pos3 = portcullis[x+1][joints.LEFT.ordinal()];
		                start_pos4 = portcullis[x][joints.RIGHT.ordinal()];
		                end_pos4 = portcullis[x+1][joints.RIGHT.ordinal()];
		                found = true;
		                }
		            else if (x >= arysize - 2)
		                done = true; // We have reached the end of the dataset.  Motion is done.
		            break;
		        case 1: // cheval
		            start_time = time_accumulator;
		            end_time = time_accumulator + cheval[x][joints.TIME.ordinal()];
		            if ((find_time >= start_time)&&(find_time < end_time))
		                { // If we are in the right time space, set up data for each axis
		                start_pos1 = cheval[x][joints.WRIST.ordinal()];
		                end_pos1 = cheval[x+1][joints.WRIST.ordinal()];
		                start_pos2 = cheval[x][joints.ELBOW.ordinal()];
		                end_pos2 = cheval[x+1][joints.ELBOW.ordinal()];
		                start_pos3 = cheval[x][joints.LEFT.ordinal()];
		                end_pos3 = cheval[x+1][joints.LEFT.ordinal()];
		                start_pos4 = cheval[x][joints.RIGHT.ordinal()];
		                end_pos4 = cheval[x+1][joints.RIGHT.ordinal()];
		                found = true;
		                }
		            else if (x >= arysize - 2)
		                done = true; // We have reached the end of the dataset.  Motion is done.
		            break;
		        case 2: // sally
		            start_time = time_accumulator;
		            end_time = time_accumulator + sally[x][joints.TIME.ordinal()];
		            if ((find_time >= start_time)&&(find_time < end_time))
		                { // If we are in the right time space, set up data for each axis
		                start_pos1 = sally[x][joints.WRIST.ordinal()];
		                end_pos1 = sally[x+1][joints.WRIST.ordinal()];
		                start_pos2 = sally[x][joints.ELBOW.ordinal()];
		                end_pos2 = sally[x+1][joints.ELBOW.ordinal()];
		                start_pos3 = sally[x][joints.LEFT.ordinal()];
		                end_pos3 = sally[x+1][joints.LEFT.ordinal()];
		                start_pos4 = sally[x][joints.RIGHT.ordinal()];
		                end_pos4 = sally[x+1][joints.RIGHT.ordinal()];
		                found = true;
		                }
		            else if (x >= arysize - 2)
		                done = true; // We have reached the end of the dataset.  Motion is done.
		            break;
		        case 3: // drawbridge
		            start_time = time_accumulator;
		            end_time = time_accumulator + drawbridge[x][joints.TIME.ordinal()];
		            if ((find_time >= start_time)&&(find_time < end_time))
		                { // If we are in the right time space, set up data for each axis
		                start_pos1 = drawbridge[x][joints.WRIST.ordinal()];
		                end_pos1 = drawbridge[x+1][joints.WRIST.ordinal()];
		                start_pos2 = drawbridge[x][joints.ELBOW.ordinal()];
		                end_pos2 = drawbridge[x+1][joints.ELBOW.ordinal()];
		                start_pos3 = drawbridge[x][joints.LEFT.ordinal()];
		                end_pos3 = drawbridge[x+1][joints.LEFT.ordinal()];
		                start_pos4 = drawbridge[x][joints.RIGHT.ordinal()];
		                end_pos4 = drawbridge[x+1][joints.RIGHT.ordinal()];
		                found = true;
		                }
		            else if (x >= arysize - 2)
		                done = true; // We have reached the end of the dataset.  Motion is done.
		            break;
		        }
		    if ((!found)&&(!done)) // keep looking till we're done or till we find what we're looking for.
		        {
		        x++;
		        time_accumulator = end_time;
		        }
		    }
		if ((found)&&(!done)) // If we are not done and we found a record, generate data.
		    { // We have valid data points.  Calculate target positions and speeds.
		    pos1 = interp(find_time, start_time, end_time, start_pos1, end_pos1); // interpolate for pos1
		    // Calculate speed assuming we will maintain the same average speed for this section
		    speed1 = (end_pos1 - start_pos1) / (end_time - start_time) * speed_multiplier / 5.0;
		
		    pos2 = interp(find_time, start_time, end_time, start_pos2, end_pos2); // interpolate for pos2
		    speed2 = (end_pos2 - start_pos2) / (end_time - start_time) * speed_multiplier / 5.0;
		
		    pos3 = interp(find_time, start_time, end_time, start_pos3, end_pos3); // interpolate for pos2
		    speed3 = (end_pos3 - start_pos3) / (end_time - start_time) * speed_multiplier / 5.0;
		
		    pos4 = interp(find_time, start_time, end_time, start_pos4, end_pos4); // interpolate for pos2
		    speed4 = (end_pos4 - start_pos4) / (end_time - start_time) * speed_multiplier / 5.0;
		
		    wristPos = pos1;
		    elbowPos = pos2;
		    leftPos = pos3;
		    rightPos = pos4;
		    wristSpeed = speed1;
		    elbowSpeed = speed2;
		    leftSpeed = speed3;
		    rightSpeed = speed4;
		    return true; // Data has been set.  Return True.
		    }
		else // if we can't find something or we are done, return false.  Motion is to stop now.
		    return false;
		}
	
	public static void posPrint(double timeStep) {
		double localTime=0;
		while (lookup(localTime))
        {
        System.out.printf("time = %3.2f" + ", wrist pos = %5.2f "+" speed = %3.2f " +
                        ", elbow pos = %6.2f "+" speed = %3.2f " +
                        ", left pos = %3.2f "+" speed = %3.2f " +
                        ", right pos = %3.2f "+" speed = %3.2f "+"\n", localTime, wristPos, wristSpeed, elbowPos, elbowSpeed, leftPos, leftSpeed, rightPos, rightSpeed);
        localTime = localTime +timeStep;

        }
	}
	public void afterShoot() {
		setManipulatorElbow(elbowAfterShootPosition);
		if (Math.abs(manipulatorElbow.getError()) < 100 && count > 10) {
			setManipulatorWrist(wristRestPosition);
			count = 0;
		}
		count++;
		System.out.println("ELBOW ERROR: " + manipulatorElbow.getError());
	}
	public boolean sallyPort() {
		fpgaDiff = Timer.getFPGATimestamp() - lastFPGA;
		lastFPGA = Timer.getFPGATimestamp();
		switch(sallyState) {
		case 0:
			setManipulatorWrist(wristSallyReady);
			if (manipulatorWrist.getError() < 250 && count > 10) {
				setManipulatorElbow(elbowSallyReady);
				sallyState++;
				count = 0;
			}
			count++;
		break;
		case 1:
			if (manipulatorElbow.getError() < 250 && count > 10) {
				sallyState++;
				totalTime = 1.0;
				timeCount = 0;
				Robot.robotDrive.resetGoToDistanceState();
			}
			count ++;
		break;
		case 2:
			timeCount += fpgaDiff;
//			encoderPosition = (encoderSallyMax - 0) * timeCount / totalTime + 0;
//			speed = ((encoderSallyMax - 0) / totalTime) / SPEED_FACTOR;
////			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
//			Robot.robotDrive.setRightMotor(-1);
//			Robot.robotDrive.setLeftMotor(-1);
//			if (Robot.robotDrive.getRightEncoder() > encoderSallyMax) {
//				Robot.robotDrive.setRightMotor(0);
//				Robot.robotDrive.setLeftMotor(0);
//				sallyState++;
//				timeCount = 0;
//				totalTime = 1.0;
//			}
			if (Robot.robotDrive.goToDistance(-120, -120, 0.95, 5, 5, 0.9, 0.9)) {
				Robot.robotDrive.setRightMotor(0);
				Robot.robotDrive.setLeftMotor(0);
				sallyState++;
				timeCount = 0;
				totalTime = 1.0;
			}
		break;
		case 3:
			timeCount++;
			if (timeCount > 15) {
				sallyState++;
			}
			break;
		case 4:
//			encoderPosition = (0 - encoderSallyMax) * timeCount / totalTime + encoderSallyMax;
//			speed = ((0 - encoderSallyMax) / totalTime) / SPEED_FACTOR;
////			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
//			Robot.robotDrive.setRightMotor(1);
//			Robot.robotDrive.setLeftMotor(1);
			Robot.robotDrive.goToDistance(1000, 1000, 0.95, 5, 5, 0.9, 0.9);
			if (Robot.robotDrive.getFrontLightSensorValue() > 1200) {
				sallyState++;
				Robot.robotDrive.setRightMotor(0);
				Robot.robotDrive.setLeftMotor(0);
				timeCount = 0;
				totalTime = 1.0;
				Robot.robotDrive.resetGoToDistanceState();
				return true;
			}
			timeCount += 0.02;
//			if (Robot.robotDrive.getRightEncoder() < 0) {
//				sallyState++;
//				Robot.robotDrive.setRightMotor(0);
//				Robot.robotDrive.setLeftMotor(0);
//				timeCount = 0;
//				totalTime = 1.0;
//				return true;
//			}
			break;		
		}
		return false;	
	}
	public boolean drawBridge() {
		fpgaDiff = Timer.getFPGATimestamp() - lastFPGA;
		lastFPGA = Timer.getFPGATimestamp();
		System.out.println("ACTUAL TIME: " + Timer.getFPGATimestamp());
		switch(drawBridgeState) {
		case 0:
			Robot.robotDrive.resetEncoders();
			setManipulatorWrist(drawBridgeWristReady);
			if (manipulatorWrist.getError() < 1000 && count > 10) {
				drawBridgeState++;
				count = 0;
			}
			count++;
			break;
		case 1:
			setManipulatorElbow(drawBridgeElbowReady);
			if (manipulatorElbow.getError() < 200 && count > 10) {
				drawBridgeState++;
				count = 0;
			}
			count++;
			break;
		case 2:
			manipulatorWrist.changeControlMode(TalonControlMode.PercentVbus);
			manipulatorWrist.set(0.1);
			drawBridgeState++;
			timeCount = 0;
			totalTime = 0.75;
			break;
		case 3:
			timeCount += fpgaDiff;
			newElbowPosition = (elbowSecondPosition - drawBridgeElbowReady) * timeCount / totalTime + drawBridgeElbowReady;
			setManipulatorElbow(newElbowPosition);
			encoderPosition = encoderSecondPosition * timeCount / totalTime;
			speed = (encoderSecondPosition / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			
			if (timeCount > totalTime) {
				manipulatorWrist.changeControlMode(TalonControlMode.Position);
				setManipulatorWrist(wristSecondPosition);
				timeCount = 0;
				totalTime = 0.75;
				drawBridgeState++;
			}
			if (manipulatorWrist.get() > wristSecondPosition - 500) {
				manipulatorWrist.changeControlMode(TalonControlMode.Position);
				setManipulatorWrist(wristSecondPosition);
			}
			break;
		case 4:
			timeCount += fpgaDiff;
			//Robot.robotDrive.DrivePath(encoderSecondPosition, 0, encoderSecondPosition, 0); //stop
			newElbowPosition = (elbowThirdPosition - elbowSecondPosition) * timeCount / totalTime + elbowSecondPosition;
			newWristPosition = (wristThirdPosition - wristSecondPosition) * timeCount / totalTime + wristSecondPosition;
			encoderPosition = (encoderThirdPosition - encoderSecondPosition) * timeCount / totalTime + encoderSecondPosition;
			speed = ((encoderThirdPosition - encoderSecondPosition) / totalTime) / SPEED_FACTOR;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 0.5;
			}
			break;
		case 5:
			timeCount += fpgaDiff;
			//Robot.robotDrive.DrivePath(encoderThirdPosition, 0, encoderThirdPosition, 0); //stop
			newElbowPosition = (elbowFourthPosition - elbowThirdPosition) * timeCount / totalTime + elbowThirdPosition;
			newWristPosition = (wristFourthPosition - wristThirdPosition) * timeCount / totalTime + wristThirdPosition;
			encoderPosition = (encoderFourthPosition - encoderThirdPosition) * timeCount / totalTime + encoderThirdPosition;
			speed = ((encoderFourthPosition - encoderThirdPosition) / totalTime) / SPEED_FACTOR;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 0.75;
				manipulatorWrist.changeControlMode(TalonControlMode.PercentVbus);
				manipulatorWrist.set(0);
			}
			break;
		case 6:
			timeCount += fpgaDiff;
			newElbowPosition = (elbowFifthPosition - elbowFourthPosition) * timeCount / totalTime + elbowFourthPosition;
			//newWristPosition = (wristFifthPosition - wristFourthPosition) * timeCount / totalTime + wristFourthPosition;
			encoderPosition = (encoderFifthPosition - encoderFourthPosition) * timeCount / totalTime + encoderFourthPosition;
			speed = ((encoderFifthPosition - encoderFourthPosition) / totalTime) / SPEED_FACTOR;
			setManipulatorElbow(newElbowPosition);
			//setManipulatorWrist(newWristPosition);
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 0.3;
			}
			break;
		case 7:
			timeCount += fpgaDiff;
			newElbowPosition = (elbowSixthPosition - elbowFifthPosition) * timeCount / totalTime + elbowFifthPosition;
			setManipulatorElbow(newElbowPosition);
			Robot.robotDrive.DrivePath(encoderFifthPosition, 0, encoderFifthPosition, 0); //stop
			if (timeCount > totalTime) {
				drawBridgeState++;
				timeCount = 0;
				totalTime = 1.0;
			}
			break;
		case 8:
			manipulatorWrist.changeControlMode(TalonControlMode.Position);
			Robot.robotDrive.DrivePath(encoderFifthPosition, 0, encoderFifthPosition, 0); //stop
			return true;
		}
		System.out.println("Case: " + drawBridgeState + ", " + "Angular wrist: " + Robot.manipulatorArm.getManipulatorWristAngular() + ", " + "Wrist encoder: " + Robot.manipulatorArm.getManipulatorWristPosition());
		return false;
	}
	public boolean portcullis() {
		switch(portcullisState) {
		case 0:
			setManipulatorWrist(wristPortcullisReady);
			timeCount = 0;
			totalTime = 0.5;
			portcullisState++;
			break;
		case 1:
			encoderPosition = encoderPortcullisFirst * timeCount / totalTime;
			speed = (encoderPortcullisFirst / totalTime) / SPEED_FACTOR; //encoderPortcullisFirst
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			timeCount += 0.02;
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 2:
			encoderPosition = encoderPortcullisFirst; //* timeCount / totalTime;
			speed = (0 / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisReady - Robot.manipulatorElbowRestPosition()) * timeCount / totalTime + Robot.manipulatorElbowRestPosition();
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 3:
			encoderPosition = encoderPortcullisFirst;// * timeCount / totalTime;
			speed = (0 / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisSecond - elbowPortcullisReady) * timeCount / totalTime + elbowPortcullisReady;
			newWristPosition = (wristPortcullisSecond - wristPortcullisReady) * timeCount / totalTime + wristPortcullisReady;
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 4:
			encoderPosition = encoderPortcullisFirst;// * timeCount / totalTime;
			speed = (0 / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisThird - elbowPortcullisSecond) * timeCount / totalTime + elbowPortcullisSecond;
			newWristPosition = (wristPortcullisThird - wristPortcullisSecond) * timeCount / totalTime + wristPortcullisSecond;
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 5:
			encoderPosition = (encoderPortcullisSecond - encoderPortcullisFirst) * timeCount / totalTime + encoderPortcullisFirst;
			speed = ((encoderPortcullisSecond - encoderPortcullisFirst) / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			newElbowPosition = (elbowPortcullisFourth - elbowPortcullisThird) * timeCount / totalTime + elbowPortcullisThird;
			newWristPosition = (wristPortcullisFourth - wristPortcullisThird) * timeCount / totalTime + wristPortcullisThird;
			timeCount += 0.02;
			setManipulatorElbow(newElbowPosition);
			setManipulatorWrist(newWristPosition);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 6:
			encoderPosition = (encoderPortcullisThird - encoderPortcullisSecond) * timeCount / totalTime + encoderPortcullisSecond;
			speed = ((encoderPortcullisThird - encoderPortcullisSecond) / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			if (timeCount > totalTime) {
				timeCount = 0;
				totalTime = 0.75;
				portcullisState++;
			}
			break;
		case 7:
			encoderPosition = (encoderPortcullisThird);
			speed = ((0) / totalTime) / SPEED_FACTOR;
			Robot.robotDrive.DrivePath(encoderPosition, speed, encoderPosition, speed);
			return true;
		}
		return false;
	}
	public void exitSallyPort() {
		switch(exitSallyState) {
		case 0:
			setManipulatorWrist(wristStraightUpPosition);
			setManipulatorElbow(elbowStraightUpPosition);
			if (manipulatorWrist.getError() < 100 && count > 10) {
				exitSallyState++;
				count = 0;
			}
			count ++;
			break;
		case 1:
			setManipulatorElbow(Robot.manipulatorElbowRestPosition());
			if (manipulatorElbow.getError() < 20000 && count > 10) {
				exitSallyState = 0;
				count = 0;
				setManipulatorMode("Rest" );
			}
			count ++;
		}
		
	}

}



