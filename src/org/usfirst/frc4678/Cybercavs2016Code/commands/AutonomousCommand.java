// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code.commands;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;

public class AutonomousCommand extends AbstractCommand {

	private static final int TURN_90 = 3;
	private static final int TRAVERSE_OUTER_WORKS = 1;
	private static final int MOVE_TO_OUTER_WORKS = 0;
	private static final int RAMPARTS = 1;
	private static final int MOAT = 0;
	private static final int STRAIGHTEN_OUT = 2;
	
//	enum RampartCaseType {TURN_90, TRAVERSE_OUTER_WORKS, MOVE_TO_OUTER_WORKS, STRAIGHTEN_OUT};
//	RampartCaseType rampartCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
//	
//	RampartCaseType moatCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
	int count = 0;
	int autoMode = 0;
	int rampartCase = 0;
	int moatCase = 0;
	boolean isFinished = false;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommand() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		Robot.robotDrive.resetGyro();
		autoMode = Robot.autoMode();
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		switch(autoMode) {
		case MOAT:	
			moatAuto();
			break;
		case RAMPARTS:
			rampartsAuto(); 
			break;
		}
	}

	private void rampartsAuto() {
		switch(rampartCase) {
		case MOVE_TO_OUTER_WORKS:
			if (Robot.robotDrive.goToDistance(140, 140, 0.5, 30, 30, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(1000, 1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
			break;
		case STRAIGHTEN_OUT:
			
			if (count > 15) { //just provides a slight wait before the robot turns
				Robot.robotDrive.resetGyro();
				rampartCase++;
			}
			if (count > 5) {
				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
			}
			count++;
			break;
		case TURN_90:
			Robot.robotDrive.gyroTurn(90); // this will depend on the position we are in, likely change this later
			break;
		}
	}

	private void moatAuto() {
		switch(moatCase)  {
		case MOVE_TO_OUTER_WORKS:
			//Robot.robotDrive.resetGyro();
			if (Robot.robotDrive.goToDistance(130, 130, 0.5, 30, 30, 0.2, 0.2)) {//188
				moatCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(2000, 2000, 0.37, 0, 270, 0.37, 0.3);
			if (Robot.robotDrive.isFlat()) {
				moatCase++;
			}
			break;
		case STRAIGHTEN_OUT:
			if (count > 15) {
				Robot.robotDrive.resetGyro();
				moatCase++;
			}
			if (count > 5) {
				Robot.robotDrive.gyroTurn(0);
			}
			count++;
			break;
		case TURN_90:
			Robot.robotDrive.gyroTurn(90);
			break;
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
	}
}
