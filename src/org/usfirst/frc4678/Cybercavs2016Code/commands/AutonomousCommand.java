// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code.commands;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;

import edu.wpi.first.wpilibj.command.Command;

public class AutonomousCommand extends Command {

	
	
	public int previousShooterState = 0;
	
	private static final int RAMPARTS = 1;
	private static final int MOAT = 0;

	
	//RAMPARTS auto states
	private static final int MOVE_TO_OUTER_WORKS = 0;
	private static final int TRAVERSE_OUTER_WORKS = 1;
	private static final int MOVE_SLIGHTLY_FORWARD = 2;
	private static final int STRAIGHTEN_OUT = 3;
	private static final int TURN_180 = 4;
	private static final int READY_CAMERA_AND_LIGHTS = 6;
	private static final int AUTO_AIM = 7;
	private static final int SHOOT = 8;
	private static final int STRAIGHTEN = 9;
	private static final int MOVE_TO_NEUTRAL_ZONE = 11;
	private static final int MOVE_TO_OUTER_WORK = 10;
	
//	enum RampartCaseType {TURN_90, TRAVERSE_OUTER_WORKS, MOVE_TO_OUTER_WORKS, STRAIGHTEN_OUT};
//	RampartCaseType rampartCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
//	
//	RampartCaseType moatCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
	int count = 0;
	int autoMode = 0;
	int rampartCase = 0;
	int moatCase = 0;
	int lowBarCase = 0;
	int drawBridgeCase = 0;
	double timeIdx = 0;
	boolean isFinished = false;
	double amountToTurn = 0;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommand() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.robotDrive);
		requires(Robot.manipulatorArm);
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		
		Robot.robotDrive.setIsInAuto(true);
		Robot.robotDrive.resetGyro();
		Robot.robotDrive.resetEncoders();
		autoMode = Robot.autoMode();
		Robot.pickupArm.setArmMode("Hold");
		if (Robot.autoPosition() == 2) {
			amountToTurn = 45;
		}
		else if (Robot.autoPosition() == 5) {
			amountToTurn = -45;
		}
		else {
			amountToTurn = 0;
		}
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		switch(autoMode) {
		case MOAT:	
			moatAuto();
			break;
		case RAMPARTS:
			rampartsAuto(); 
			break;
		case 2:
			if (count > 50) {
				Robot.catapult.shootBoulder();
			}
			else {
				Robot.pickupArm.setArmMode("ShootMode");
				Robot.manipulatorArm.setManipulatorMode("ShootMode");
			}
			count++;
			break;
		case 3:
			low_Bar_Auto();
			break;
			
		case 4:
			switch(drawBridgeCase) {
			case 0:
				Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);//188
				if (Robot.robotDrive.getFrontLightSensorValue() > 1200) {
					Robot.robotDrive.resetGoToDistanceState();
					count = 0;
					drawBridgeCase++;
				}
				break;
			case 1:
				Robot.robotDrive.goToDistance(1000, 1000, 0.5, 30, 30, 0.4, 0.4);//188
				if (Math.abs(Robot.robotDrive.getLeftSpeed()) < 50 && count > 10) {
					Robot.robotDrive.setLeftMotor(0);
					Robot.robotDrive.setRightMotor(0);
					Robot.manipulatorArm.setManipulatorElbowMode(5);
			    	Robot.manipulatorArm.setManipulatorWristMode(5);
			    	Robot.manipulatorArm.resetCount();
			    	Robot.manipulatorArm.resetDrawBridgeState();
					drawBridgeCase++;
				}
				count++;
				break;
			case 2:
				if(Robot.manipulatorArm.drawBridge()) {
					drawBridgeCase++;
				}
				break;
			case 3:
				Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);
				if(Robot.robotDrive.isFlat()) {
					drawBridgeCase++;
				}
				if (Math.abs(Robot.manipulatorArm.getElbowError()) < 2500 && count > 10) {
					Robot.manipulatorArm.setManipulatorWrist(Robot.manipulatorWristRestPosition());
				}
				else {
					Robot.manipulatorArm.setManipulatorWrist(Robot.manipulatorWristRestPosition() - 3500);
				}
			
					count++;
				Robot.manipulatorArm.setManipulatorElbow(Robot.manipulatorElbowRestPosition());
				break;
			case 4:
				if (Robot.autoPosition() == 2) {
					if (Robot.robotDrive.goToDistance(100, 100, 0.8, 30, 30, 0.4, 0.4)) {
						drawBridgeCase++;
					}
				}
				
				break;	
			case 5:
				if(Robot.robotDrive.gyroTurn(amountToTurn)) {
					drawBridgeCase++;
				}
				break;
			case 6:
				Robot.camera.cameraLightsOn();
				Robot.robotDrive.autoAimInit();
				Robot.manipulatorArm.setManipulatorMode("ShootMode");
				Robot.pickupArm.setArmMode("ShootMode");
				drawBridgeCase++;
				break;
			case 7:
				if(Robot.robotDrive.autoAim()) {
					drawBridgeCase++;
					Robot.camera.cameraLightsOff();
				}
				else {
					Robot.camera.cameraLightsOn();
				}
				break;
			case 8:
				Robot.catapult.shootBoulder();
				count ++;
				if (count > 20) { // just so it doens't move immediatly after shooting
					drawBridgeCase++;
					count = 0;
				}
				break;
			case 9:
				Robot.catapult.shootBoulder();
				break;
			}
			break;
		}
		System.out.println("Case: " + drawBridgeCase + " AUTO MODE: " + Robot.autoMode());
	}

	private void low_Bar_Auto() {
		switch(lowBarCase) {
		case 0:
			//Robot.robotDrive.resetGyro();
			Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.getFrontLightSensorValue() > 1200) {
				Robot.robotDrive.resetGoToDistanceState();
				lowBarCase++;
			}
			break;
		case 1:
			Robot.pickupArm.setArmMode("lowBar");
			Robot.robotDrive.goToDistance(1000, 1000, 0.6, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.isFlat()) {
				Robot.pickupArm.setArmMode("ShootMode");
				Robot.robotDrive.resetGoToDistanceState();
				lowBarCase++;
			}
			break;
		case 2:
			if (Robot.robotDrive.goToDistance(190, 190, 0.8, 30, 30, 0.4, 0.4)) {
				lowBarCase++;
				Robot.robotDrive.resetEncoders();
				timeIdx = 0;
			}
			break;
		case 3:
			double speed = 10;
			double leftPos = timeIdx * speed;
			double rightPos = timeIdx * -speed;
			if (timeIdx < 150 / speed) {
				Robot.robotDrive.DrivePath(leftPos, speed * 5, rightPos, -(speed * 5));
			} else {
				Robot.robotDrive.DrivePath(150, 0, -150, 0);
			}
			if (timeIdx > 200 / speed) {
				Robot.robotDrive.setLeftMotor(0);
				Robot.robotDrive.setRightMotor(0);
				lowBarCase++;
			}
			timeIdx++;
			break;
		case 4:
			Robot.camera.cameraLightsOn();
			Robot.robotDrive.autoAimInit();
			Robot.manipulatorArm.setManipulatorMode("ShootMode");
			lowBarCase++;
			break;
		case 5:
			if(Robot.robotDrive.autoAim()) {
				lowBarCase++;
				Robot.camera.cameraLightsOff();
			}
			else {
				Robot.camera.cameraLightsOn();
			}
			break;
		case 6:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) { // just so it doens't move immediatly after shooting
				lowBarCase++;
				count = 0;
			}
			break;
		case 7:
			Robot.catapult.shootBoulder();
		break;
		}
	}
	

	private void rampartsAuto() {
		switch(rampartCase) {
		case MOVE_TO_OUTER_WORKS:
			if (Robot.robotDrive.goToDistance(140, 140, 0.5, 30, 30, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(1000, 1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
			break;
		case MOVE_SLIGHTLY_FORWARD: 
			if (Robot.robotDrive.goToDistance(50, 50, 0.2, 0, 50, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case STRAIGHTEN_OUT:
			
			if (count > 15) { //just provides a slight wait before the robot turns
				Robot.robotDrive.resetGyro();
				rampartCase++;
			}
			if (count > 5) {
				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
			}
			count++;
			break;
		case TURN_180:
			Robot.robotDrive.setLeftTarg(500); // this will depend on the position we are in, likely change this later
			Robot.robotDrive.setRightTarg(500);
			Robot.robotDrive.findTarget();
			break;
		case READY_CAMERA_AND_LIGHTS:
			Robot.camera.cameraLightsOn();
	    	Robot.robotDrive.autoAimInit();
	    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
	    	Robot.pickupArm.setArmMode("ShootMode");
	    	rampartCase++;
	    	break;
		case AUTO_AIM:
			if(Robot.robotDrive.autoAim()) {
				rampartCase++;
	    		Robot.camera.cameraLightsOff();
	    	}
	    	Robot.camera.cameraLightsOn();
	    	break;
		case SHOOT:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) { // just so it doens't move immediatly after shooting
				rampartCase++;
				count = 0;
			}
			break;
		case STRAIGHTEN:
			Robot.robotDrive.setLeftTarg(0); // this will depend on the position we are in, likely change this later
			Robot.robotDrive.setRightTarg(0);
			Robot.robotDrive.findTarget();
			break;
		case MOVE_TO_OUTER_WORK:
			Robot.robotDrive.goToDistance(-1000, -1000, 0.5, 0, 50, 0.3, 0.3);
			if (Robot.robotDrive.getBackLightSensorValue() > 2000) {
				rampartCase++;
			}
			break;
		case MOVE_TO_NEUTRAL_ZONE:
			Robot.robotDrive.goToDistance(-1000, -1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
		}
	}

	private void moatAuto() {
		switch(moatCase)  {
		case MOVE_TO_OUTER_WORKS:
			//Robot.robotDrive.resetGyro();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.8, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.getBackLightSensorValue() > 1200) {
				Robot.robotDrive.resetGoToDistanceState();
				moatCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(-2000, -2000, 1.0, 5, 5, 0.9, 0.9);
			if (Robot.robotDrive.isFlat()) {
				moatCase++;
			}
			break;
		case MOVE_SLIGHTLY_FORWARD: 
//			if (Robot.robotDrive.goToDistance(-100, -100, 0.8, 0, 50, 0.7, 0.7)) {
//				
//			}
			if (count > 10) {
				moatCase++;
				count = 0;
			}
			count++;
			break;
		case STRAIGHTEN_OUT:
			
//			if (count > 15) { //just provides a slight wait before the robot turns
//				Robot.robotDrive.resetGyro();
//				
//			}
//			if (count > 5) {
//				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
//			}
			count = 0;
			Robot.robotDrive.resetEncoders();
			Robot.robotDrive.resetGoToDistanceState();
			moatCase++;
			break;
		case TURN_180:
	    	//Robot.robotDrive.setTarget(690, -690);
	    	 // this will depend on the position we are in, likely change this later
			if (Robot.robotDrive.goToDistance(90.5, -90.5, 0.9, 0, 10, 0.7, 0.3)) {
				moatCase++;
			}
			break;
		case 5:
			if (count > 10) {
				if (Robot.robotDrive.goToDistance(10, 10, 0.9, 0, 50, 0.7, 0.7)) {
					moatCase++;
				}
				
			}
			count++;
			break;
		case READY_CAMERA_AND_LIGHTS:
			count = 0;
			Robot.camera.cameraLightsOn();
	    	Robot.robotDrive.autoAimInit();
	    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
	    	Robot.pickupArm.setArmMode("ShootMode");
	    	moatCase++;
	    	break;
		case AUTO_AIM:
			if(Robot.robotDrive.autoAim()) {
				moatCase++;
	    		Robot.camera.cameraLightsOff();
	    	}
			else {
				Robot.camera.cameraLightsOn();
			}
	    	break;
		case SHOOT:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) {
				//moatCase++;
				count = 0;
			}
			break;
		case STRAIGHTEN:
//			Robot.robotDrive.setTarget(0, 0);
//	    	//Robot.robotDrive.resetEncoders();
//			Robot.robotDrive.findTarget();
			Robot.catapult.shootBoulder();
			moatCase++;
			break;
		case MOVE_TO_OUTER_WORK:
			Robot.catapult.shootBoulder();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.9, 0, 50, 0.7, 0.7);
			if (Robot.robotDrive.getBackLightSensorValue() > 2000) {
				moatCase++;
			}
			break;
		case MOVE_TO_NEUTRAL_ZONE:
			Robot.catapult.shootBoulder();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.9, 0, 50, 0.7, 0.7);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				moatCase++;
			}
			break;
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.catapult.setPreviousShooterState(Robot.catapult.shooterState);
		Robot.catapult.setWinchMotor(0);
		Robot.robotDrive.setIsInAuto(false);
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}
}
