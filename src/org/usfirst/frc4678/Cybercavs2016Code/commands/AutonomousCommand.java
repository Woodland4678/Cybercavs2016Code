// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4678.Cybercavs2016Code.commands;

import org.usfirst.frc4678.Cybercavs2016Code.Robot;

import edu.wpi.first.wpilibj.command.Command;

public class AutonomousCommand extends Command {

	
	
	public int previousShooterState = 0;
	
	private static final int RAMPARTS = 1;
	private static final int MOAT = 0;

	
	//RAMPARTS auto states
	private static final int MOVE_TO_OUTER_WORKS = 0;
	private static final int TRAVERSE_OUTER_WORKS = 1;
	private static final int MOVE_SLIGHTLY_FORWARD = 2;
	private static final int STRAIGHTEN_OUT = 3;
	private static final int TURN_180 = 4;
	private static final int READY_CAMERA_AND_LIGHTS = 6;
	private static final int AUTO_AIM = 7;
	private static final int SHOOT = 8;
	private static final int STRAIGHTEN = 9;
	private static final int MOVE_TO_NEUTRAL_ZONE = 11;
	private static final int MOVE_TO_OUTER_WORK = 10;
	
//	enum RampartCaseType {TURN_90, TRAVERSE_OUTER_WORKS, MOVE_TO_OUTER_WORKS, STRAIGHTEN_OUT};
//	RampartCaseType rampartCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
//	
//	RampartCaseType moatCase = RampartCaseType.MOVE_TO_OUTER_WORKS;
	int count = 0;
	int autoMode = 0;
	int rampartCase = 0;
	int moatCase = 0;
	int lowBarCase = 0;
	double timeIdx = 0;
	boolean isFinished = false;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommand() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	// Called just before this Command runs the first time
	protected void initialize() {
		Robot.robotDrive.setIsInAuto(true);
		Robot.robotDrive.resetGyro();
		autoMode = Robot.autoMode();
		Robot.pickupArm.setArmMode("Hold");
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		switch(autoMode) {
		case MOAT:	
			moatAuto();
			break;
		case RAMPARTS:
			rampartsAuto(); 
			break;
		case 2:
			if (count > 50) {
				Robot.catapult.shootBoulder();
			}
			else {
				Robot.pickupArm.setArmMode("ShootMode");
				Robot.manipulatorArm.setManipulatorMode("ShootMode");
			}
			count++;
			break;
		case 3:
			switch(lowBarCase) {
			case 0:
				//Robot.robotDrive.resetGyro();
				Robot.robotDrive.goToDistance(1000, 1000, 0.8, 30, 30, 0.4, 0.4);//188
				if (Robot.robotDrive.getFrontLightSensorValue() > 1200) {
					Robot.robotDrive.resetGoToDistanceState();
					lowBarCase++;
				}
				break;
			case 1:
				Robot.pickupArm.setArmMode("lowBar");
				Robot.robotDrive.goToDistance(1000, 1000, 0.6, 30, 30, 0.4, 0.4);//188
				if (Robot.robotDrive.isFlat()) {
					Robot.robotDrive.resetGoToDistanceState();
					lowBarCase++;
				}
				break;
			case 2:
				if (Robot.robotDrive.goToDistance(190, 190, 0.8, 30, 30, 0.4, 0.4)) {
					lowBarCase++;
					Robot.robotDrive.resetEncoders();
					timeIdx = 0;
				}
				break;
			case 3:
				double speed = 10;
				double leftPos = timeIdx * speed;
				double rightPos = timeIdx * -speed;
				Robot.robotDrive.DrivePath(leftPos, speed * 5, rightPos, -(speed * 5));
				timeIdx++;
				if (timeIdx > 150 / speed) {
					Robot.robotDrive.setLeftMotor(0);
					Robot.robotDrive.setRightMotor(0);
					lowBarCase++;
				}
				break;
			case 4:
				Robot.camera.cameraLightsOn();
		    	Robot.robotDrive.autoAimInit();
		    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
		    	Robot.pickupArm.setArmMode("ShootMode");
		    	lowBarCase++;
		    	break;
			case 5:
				if(Robot.robotDrive.autoAim()) {
					lowBarCase++;
		    		Robot.camera.cameraLightsOff();
		    	}
				else {
					Robot.camera.cameraLightsOn();
				}
		    	break;
			case 6:
				Robot.catapult.shootBoulder();
				count ++;
				if (count > 20) { // just so it doens't move immediatly after shooting
					lowBarCase++;
					count = 0;
				}
				break;
			case 7:
				Robot.catapult.shootBoulder();
			break;
			}
		}
		System.out.println("Case: " + moatCase);
	}

	private void rampartsAuto() {
		switch(rampartCase) {
		case MOVE_TO_OUTER_WORKS:
			if (Robot.robotDrive.goToDistance(140, 140, 0.5, 30, 30, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(1000, 1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
			break;
		case MOVE_SLIGHTLY_FORWARD: 
			if (Robot.robotDrive.goToDistance(50, 50, 0.2, 0, 50, 0.2, 0.2)) {
				rampartCase++;
			}
			break;
		case STRAIGHTEN_OUT:
			
			if (count > 15) { //just provides a slight wait before the robot turns
				Robot.robotDrive.resetGyro();
				rampartCase++;
			}
			if (count > 5) {
				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
			}
			count++;
			break;
		case TURN_180:
			Robot.robotDrive.setLeftTarg(500); // this will depend on the position we are in, likely change this later
			Robot.robotDrive.setRightTarg(500);
			Robot.robotDrive.findTarget();
			break;
		case READY_CAMERA_AND_LIGHTS:
			Robot.camera.cameraLightsOn();
	    	Robot.robotDrive.autoAimInit();
	    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
	    	Robot.pickupArm.setArmMode("ShootMode");
	    	rampartCase++;
	    	break;
		case AUTO_AIM:
			if(Robot.robotDrive.autoAim()) {
				rampartCase++;
	    		Robot.camera.cameraLightsOff();
	    	}
	    	Robot.camera.cameraLightsOn();
	    	break;
		case SHOOT:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) { // just so it doens't move immediatly after shooting
				rampartCase++;
				count = 0;
			}
			break;
		case STRAIGHTEN:
			Robot.robotDrive.setLeftTarg(0); // this will depend on the position we are in, likely change this later
			Robot.robotDrive.setRightTarg(0);
			Robot.robotDrive.findTarget();
			break;
		case MOVE_TO_OUTER_WORK:
			Robot.robotDrive.goToDistance(-1000, -1000, 0.5, 0, 50, 0.3, 0.3);
			if (Robot.robotDrive.getBackLightSensorValue() > 2000) {
				rampartCase++;
			}
			break;
		case MOVE_TO_NEUTRAL_ZONE:
			Robot.robotDrive.goToDistance(-1000, -1000, 0.2, 0, 50, 0.2, 0.2);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				rampartCase++;
			}
		}
	}

	private void moatAuto() {
		switch(moatCase)  {
		case MOVE_TO_OUTER_WORKS:
			//Robot.robotDrive.resetGyro();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.8, 30, 30, 0.4, 0.4);//188
			if (Robot.robotDrive.getBackLightSensorValue() > 1200) {
				Robot.robotDrive.resetGoToDistanceState();
				moatCase++;
			}
			break;
		case TRAVERSE_OUTER_WORKS:
			Robot.robotDrive.goToDistance(-2000, -2000, 1.0, 5, 5, 0.9, 0.9);
			if (Robot.robotDrive.isFlat()) {
				moatCase++;
			}
			break;
		case MOVE_SLIGHTLY_FORWARD: 
//			if (Robot.robotDrive.goToDistance(-100, -100, 0.8, 0, 50, 0.7, 0.7)) {
//				
//			}
			if (count > 10) {
				moatCase++;
				count = 0;
			}
			count++;
			break;
		case STRAIGHTEN_OUT:
			
//			if (count > 15) { //just provides a slight wait before the robot turns
//				Robot.robotDrive.resetGyro();
//				
//			}
//			if (count > 5) {
//				Robot.robotDrive.gyroTurn(0); //just in case we got turned when we traversed the other works
//			}
			count = 0;
			Robot.robotDrive.resetEncoders();
			Robot.robotDrive.resetGoToDistanceState();
			moatCase++;
			break;
		case TURN_180:
	    	//Robot.robotDrive.setTarget(690, -690);
	    	 // this will depend on the position we are in, likely change this later
			if (Robot.robotDrive.goToDistance(90.5, -90.5, 0.9, 0, 10, 0.7, 0.3)) {
				moatCase++;
			}
			break;
		case 5:
			if (count > 10) {
				if (Robot.robotDrive.goToDistance(10, 10, 0.9, 0, 50, 0.7, 0.7)) {
					moatCase++;
				}
				
			}
			count++;
			break;
		case READY_CAMERA_AND_LIGHTS:
			count = 0;
			Robot.camera.cameraLightsOn();
	    	Robot.robotDrive.autoAimInit();
	    	Robot.manipulatorArm.setManipulatorMode("ShootMode");
	    	Robot.pickupArm.setArmMode("ShootMode");
	    	moatCase++;
	    	break;
		case AUTO_AIM:
			if(Robot.robotDrive.autoAim()) {
				moatCase++;
	    		Robot.camera.cameraLightsOff();
	    	}
			else {
				Robot.camera.cameraLightsOn();
			}
	    	break;
		case SHOOT:
			Robot.catapult.shootBoulder();
			count ++;
			if (count > 20) {
				//moatCase++;
				count = 0;
			}
			break;
		case STRAIGHTEN:
//			Robot.robotDrive.setTarget(0, 0);
//	    	//Robot.robotDrive.resetEncoders();
//			Robot.robotDrive.findTarget();
			Robot.catapult.shootBoulder();
			moatCase++;
			break;
		case MOVE_TO_OUTER_WORK:
			Robot.catapult.shootBoulder();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.9, 0, 50, 0.7, 0.7);
			if (Robot.robotDrive.getBackLightSensorValue() > 2000) {
				moatCase++;
			}
			break;
		case MOVE_TO_NEUTRAL_ZONE:
			Robot.catapult.shootBoulder();
			Robot.robotDrive.goToDistance(-1000, -1000, 0.9, 0, 50, 0.7, 0.7);
			if (Robot.robotDrive.isFlat()) { //if both light sensors see carpet, it means we are flat on the other side of the outer works
				moatCase++;
			}
			break;
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
		Robot.catapult.setPreviousShooterState(Robot.catapult.shooterState);
		Robot.catapult.setWinchMotor(0);
		Robot.robotDrive.setIsInAuto(false);
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
		end();
	}
}
